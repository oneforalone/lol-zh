<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>译者序 &mdash; Let Over Lambda 中文文档  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="第一章：概述" href="chapter01.html" />
    <link rel="prev" title="Let Over Lambda 中文版" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Let Over Lambda 中文文档
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">译者序</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#lisp">我的 Lisp 之路</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">关于本书</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">关于翻译</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">最后的最后</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="chapter01.html">第一章：概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter02.html">第二章：闭包</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter03.html">第三章：宏基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter04.html">第四章：读取宏 <sup>（1）</sup></a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter05.html">第五章：Programs that program <sup>（1）</sup></a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter06.html">第六章：回指 <sup>（1）</sup> 宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter07.html">第七章：宏的效率</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter08.html">第八章：Lisp 和 Forth</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendices.html">附录</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">参考文档</a></li>
<li class="toctree-l1"><a class="reference internal" href="specification.html">术语表</a></li>
<li class="toctree-l1"><a class="reference internal" href="original-code.html">源代码</a></li>
<li class="toctree-l1"><a class="reference internal" href="production-code.html">生产代码</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Let Over Lambda 中文文档</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>译者序</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/preface.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="preface">
<span id="id1"></span><h1>译者序<a class="headerlink" href="#preface" title="Permalink to this heading"></a></h1>
<section id="lisp">
<h2>我的 Lisp 之路<a class="headerlink" href="#lisp" title="Permalink to this heading"></a></h2>
<p>其实，最开始接触 Lisp 是因为大二无聊时看了长铗的 <a class="reference external" href="https://www.513gp.org/book/4709/224736.html">屠龙之技</a> ，
然后暑假就看了一下 <a class="reference external" href="https://gigamonkeys.com/book/">Practical Common Lisp</a> 和 <a class="reference external" href="http://www.paulgraham.com/acl.html">ANSI Common Lisp</a> 。
结果也只是看了一下，因为我是上大学后才开始接触计算机，然后大一学的又是 C，所以也只是看了一遍，
并没有说真正的入门 Lisp，因为我对 REPL 这种模式很陌生，同时对计算机这一学科的基础知识积累的
也很少。当时验证书中的例子使用的是 <a class="reference external" href="https://lispbox.common-lisp.dev">Lispbox</a> ，
但那只是将 <code class="docutils literal notranslate"><span class="pre">sbcl</span> <span class="pre">+</span> <span class="pre">slime</span> <span class="pre">+</span> <span class="pre">emacs</span></code> 封装了一下，而且版本还都不是最新的，然后我就转而自己来
配置，结果就去玩 Emacs 了，对 CL 也就不了了之了。其实正如 <a class="reference internal" href="appendices.html#appendix-d"><span class="std std-ref">附录 D：Lisp 编辑器</span></a> 中 Doug
说的一样，Emacs 是个很好的编辑器，但是其设计的最终目的是辅助进行编辑，而不是辅助编写代码。在之
后的两年时间中，我花了大部分的精力在配置一个自己舒服的编辑器，找各种插件，自己写配置。最终的结果
是：对 lisp 的理解并没有加深，而 Emacs 也因为各种插件导致启动较慢。期间把 <a class="reference external" href="https://mitpress.mit.edu/sites/default/files/sicp/index.html">SICP</a> 看了一遍，发现重要的还是编程的思想，而不是工具的配置，就开始慢慢对 Emacs 的热情褪去，开始找对应的Lisp 书籍看。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Emacs 启动慢也研究了一段时间，一开始是通过 <strong>autoload</strong> 来延后加载插件来降低启动时间，
进步一是启动时以 server 的模式启动，然后每次打开都是直接开启一个 buffer，虽然也很快，但是
第一次启动还是比较慢，同时如果是在新机器上使用还需要等很久去下载那些插件。Anyway，青菜萝卜，
各有所爱，就像 <a class="reference external" href="https://ohmyz.sh">oh-my-zsh</a> 一样，一开始是觉得很酷，可是我自己后来
发现花费大量的时间和精力去配置得到的收获并不大，或者说投入回报比不高。就不去玩这些了，老老实
实去看原理书籍。</p>
</div>
<p>直到大学毕业工作后，无聊时准备好好学习一下 Lisp 时，无意中从 <a class="reference external" href="https://common-lisp.net">Common-Lisp.net</a>
找到了 <a class="reference external" href="https://lispcookbook.github.io/cl-cookbook/">The CommonLisp Cookbook</a>
，才算是把 CL 给入门了。同时也是粗略的翻译了一下，具体的翻译的地址为 <a class="reference external" href="https://oneforalone.github.io/cl-cookbook-cn/#/">The CommonLisp Cookbook Chinese Version</a> 。
随后决定把 <a class="reference external" href="https://letoverlambda.com">Let Over Lambda</a> 看一遍然后翻译出来。
随着翻译的进行，对 Lisp 的宏也有了一定的了解，才知道为什么作者会说宏是 Lisp 的核心。因为
Lisp 的宏和其他语言的宏完全不是一个性质 —— 其他语言的宏都只是将对应的代码进行替换，而 Lisp
的宏是能根据参数生成对应的 Lisp 代码。</p>
<p>结合我自身的经历，如果是自身计算机基础比较薄弱，或者说是编程基础差的初学者来说，推荐先看一下
<a class="reference external" href="https://lispcookbook.github.io/cl-cookbook/">The CommonLisp Cookbook</a>，看完这本书前面几章后，你就能够比较轻松的去看其他的书籍了，毕
竟，如果在初学一门语言时，连 <code class="docutils literal notranslate"><span class="pre">Hello,</span> <span class="pre">World</span></code> 都写不出来，那很打击学习的激情的。遇到不懂的系
统内置函数或宏的时候，可以到 Lispworks 的 <a class="reference external" href="http://www.lispworks.com/documentation/lw70/CLHS/Front/Contents.htm">HyerSpec</a> 中查看具体使用方法。</p>
</section>
<section id="id3">
<h2>关于本书<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h2>
<p>关于这本书名，我目前还找不到很确切的中文来表达，因为 Let Over Lambda 是 Doug 对闭包的描述，
这种说法很生动形象，所谓闭包就是函数和变量的绑定，用 Lisp 的代码写出来就是这样的：</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nv">counter</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="nb">incf</span><span class="w"> </span><span class="nv">counter</span><span class="p">)))</span><span class="w"></span>
</pre></div>
</div>
<p>上面代码返回的是里面的 lambda 函数，但是每次调用这个函数时，这个函数都会修改 <cite>counter</cite> 这个
变量，而 <strong>let</strong> 关键词是在 <strong>lambda</strong> 关键词上面，所以就叫 Let Over Lambda，很直观。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在 Lisp 中，函数和变量是分开存储的，所以函数名和变量是可以完全相同的，同时在 lisp 中，
函数也是一个类型，可以直接作为返回值。</p>
</div>
<p>当然这段代码直接执行解释器中会返回一个 <cite>#&lt;FUNCTION (LAMBDA ()) {70051DA5EB}&gt;</cite> 这样的
东西，这是提示你返回的是一个 lambda 函数。所以如果想要确认结果是不是如我们所说的，有两种方法
来进行验证。</p>
<ul class="simple">
<li><p>将 lambda 函数绑定到一个变量上：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">defvar</span> <span class="n">counter</span>
    <span class="p">(</span><span class="n">let</span> <span class="p">((</span><span class="n">counter</span> <span class="mi">0</span><span class="p">))</span>
      <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="p">(</span><span class="n">incf</span> <span class="n">counter</span><span class="p">))))</span>

<span class="o">*</span> <span class="p">(</span><span class="n">funcall</span> <span class="n">counter</span><span class="p">)</span>
<span class="mi">1</span>
<span class="o">*</span> <span class="p">(</span><span class="n">funcall</span> <span class="n">counter</span><span class="p">)</span>
<span class="mi">2</span>
<span class="o">*</span> <span class="p">(</span><span class="n">funcall</span> <span class="n">counter</span><span class="p">)</span>
<span class="mi">3</span>
</pre></div>
</div>
<ul class="simple">
<li><p>使用内置的 <cite>*</cite> 符号，其中 <cite>*</cite> 表示上个表达式的结果，<cite>**</cite> 表示上上个表达式的结果，
<cite>***</cite> 表示上上上个表达式的结果，目前 sbcl 只支持三个 <cite>*</cite> 。</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="p">(</span><span class="n">let</span> <span class="p">((</span><span class="n">counter</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="p">(</span><span class="n">incf</span> <span class="n">counter</span><span class="p">))))</span>
<span class="c1">#&lt;FUNCTION (LAMBDA ()) {70051DA5EB}&gt;</span>
<span class="o">*</span> <span class="p">(</span><span class="n">funcall</span> <span class="o">*</span><span class="p">)</span>
<span class="mi">1</span>
<span class="o">*</span> <span class="p">(</span><span class="n">funcall</span> <span class="o">**</span><span class="p">)</span>
<span class="mi">2</span>
<span class="o">*</span> <span class="p">(</span><span class="n">funcall</span> <span class="o">***</span><span class="p">)</span>
<span class="mi">3</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在 CommonLisp 中，调用执行函数需要使用 <cite>funcall</cite> 关键字</p>
</div>
<p>其实对于 Lisp 中闭包，可以类比 C 语言中的结构体或事面向对象语言中的类，都是函数和变量进行
了绑定。实际上，本书中有介绍如何使用宏和闭包完成面向对象的方法，即
<a class="reference internal" href="chapter06.html#pandoric-macros"><span class="std std-ref">6.7 潘多拉宏</span></a> 中的 pandoric 宏，很有趣的一节，很值得研究。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>虽然说近期很火的 Rust 里的宏比 C 的有一定的改进，从代码替换变成了正则匹配，但个人感觉
还是比不上 Lisp 的宏，因为 Lisp 的宏是能够执行对应的参数后然后在生成对应的代码，然后解释器
再对生成的代码进行执行。同时 Rust 中的 Ownership 给我的感觉就是 Lisp 中的词法作用域。</p>
</div>
</section>
<section id="id4">
<h2>关于翻译<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h2>
<p>因为本人的能力和时间有限，本书的翻译是我先从 pdf 中拷贝出来，然后通过翻译软件翻译一遍，
再然后自己去修改，因此会有一些拼写错误，同时也可能有些翻译出来并不是很准确或者说很绕，
如果有条件的话，推荐去阅读英文的原文。同时因为这本书是 Doug 看了 Paul 的 <a class="reference external" href="http://paulgraham.com/onlisptext.html">On Lisp</a>
后受到了启发，所以有时间的话，也推荐去看一下 <a class="reference external" href="http://paulgraham.com/onlisptext.html">On Lisp</a> 这本书。</p>
<p>还有什么呢？就是这本书中的第一人称均指代的是作者，而不是译者本人，如果是译者本人的观点或
想法，会额外的标明。同时，因为将 PDF 的格式转换成 reStructured 格式，书中的一些脚注就
还没又进行添加（P.S. 因为当时我忙着翻译，不想去研究 reStructured 怎么添加脚注，准备
留给后期校对时在进行）。毕竟，翻译和写作都是个体力活，不像写代码可以使用 CV 大法 🤪</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>之后应该不会再进行翻译了，只会在翻译的两本书的初版的基础上进行校对。然后以原创为主，记录在我自己的博客上：<a class="reference external" href="http://oneforalone.github.io">http://oneforalone.github.io</a> 。</p>
<p>如果对翻译感兴趣的话，推荐 <a class="reference external" href="https://baike.baidu.com/item/思果/8413483">思果</a> 的 <a class="reference external" href="https://book.douban.com/subject/1234604/">翻译研究</a> 和 <a class="reference external" href="https://book.douban.com/subject/1234605/">翻译新究</a> 。</p>
</div>
</section>
<section id="id9">
<h2>最后的最后<a class="headerlink" href="#id9" title="Permalink to this heading"></a></h2>
<p>Happy Lisping!</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Let Over Lambda 中文版" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="chapter01.html" class="btn btn-neutral float-right" title="第一章：概述" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021-2022, oneforalone, Treyenuo.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>